#!/usr/bin/env bash
# waypoint-cli - Command-line interface for Waypoint snapshot management
# This is a thin wrapper around D-Bus calls to waypoint-helper

set -euo pipefail

DBUS_SERVICE="tech.geektoshi.waypoint"
DBUS_PATH="/tech/geektoshi/waypoint"
DBUS_INTERFACE="tech.geektoshi.waypoint.Helper"

get_snapshot_dir() {
    local dir="${WAYPOINT_SNAPSHOT_DIR:-/.snapshots}"
    [[ "$dir" != "/" ]] && dir="${dir%/}"
    echo "$dir"
}

snapshot_path_from_name() {
    local name="$1"
    printf "%s/%s" "$(get_snapshot_dir)" "$name"
}

usage() {
    cat << EOF
Waypoint CLI - Btrfs snapshot management for Void Linux

Usage: waypoint-cli <command> [options]

SNAPSHOT OPERATIONS:
    create <name> [description] [subvolumes]
                        Create a new snapshot
    list [--verbose]    List all snapshots
    show <name>         Display detailed information about a snapshot
    diff <snapshot1> <snapshot2>
                        Compare two snapshots
    delete <name>       Delete a snapshot
    restore <name>      Restore a snapshot (rollback system)
    cleanup [--schedule-based] [--dry-run]
                        Apply retention policy to delete old snapshots
    verify <name> [--json]
                        Verify snapshot integrity
    preview-restore <name> [--json]
                        Preview restore changes without applying them

BACKUP OPERATIONS:
    backup <snapshot> <destination> [parent]
                        Create backup to external drive
    list-backups <destination>
                        List backups on a destination
    verify-backup <snapshot> <destination> <id>
                        Verify backup integrity
    restore-backup <backup-path> <snapshots-dir>
                        Restore from external backup
    scan-destinations [--json]
                        List available backup drives
    drive-stats <destination>
                        Get drive space statistics

FILE OPERATIONS:
    restore-files <snapshot> <file1> [file2...] [--target DIR] [--overwrite]
                        Restore individual files from snapshot

QUOTA MANAGEMENT:
    quota enable [--simple]
                        Enable quotas
    quota disable       Disable quotas
    quota status [--json]
                        Show quota usage
    quota set-limit <size>
                        Set quota limit (e.g., 50G, 1T)

GENERAL:
    help                Show this help message

Options:
    --json              Output in JSON format (where applicable)
    --verbose           Show detailed information
    --dry-run           Preview changes without applying them
    --overwrite         Overwrite existing files when restoring
    --simple            Use simple quota mode
    --schedule-based    Use schedule-based retention (default for cleanup)

Examples:
    waypoint-cli create "before-upgrade" "Snapshot before system upgrade"
    waypoint-cli list --verbose
    waypoint-cli backup "my-snapshot" "/mnt/backup"
    waypoint-cli restore-files "my-snapshot" /etc/fstab /etc/hosts --target /tmp
    waypoint-cli quota set-limit 100G
    waypoint-cli scan-destinations --json
    waypoint-cli cleanup --dry-run
    waypoint-cli verify "my-snapshot"

Note: All operations require authentication via Polkit.
EOF
    exit 0
}

check_dbus_service() {
    if ! busctl status "$DBUS_SERVICE" >/dev/null 2>&1; then
        echo "Error: Waypoint D-Bus service is not available." >&2
        echo "Make sure waypoint is installed and D-Bus is running." >&2
        exit 1
    fi
}

validate_snapshot_name() {
    local name="$1"

    # Check if empty
    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name cannot be empty" >&2
        return 1
    fi

    # Check length (max 255 characters)
    if [[ ${#name} -gt 255 ]]; then
        echo "Error: Snapshot name too long (max 255 characters)" >&2
        return 1
    fi

    # Check for forbidden characters and patterns
    if [[ "$name" == *"/"* ]]; then
        echo "Error: Snapshot name cannot contain '/'" >&2
        return 1
    fi

    if [[ "$name" == *".."* ]]; then
        echo "Error: Snapshot name cannot contain '..'" >&2
        return 1
    fi

    # Check if starts with - or .
    if [[ "$name" == -* ]]; then
        echo "Error: Snapshot name cannot start with '-'" >&2
        return 1
    fi

    if [[ "$name" == .* ]]; then
        echo "Error: Snapshot name cannot start with '.'" >&2
        return 1
    fi

    # Check for special names
    if [[ "$name" == "." || "$name" == ".." ]]; then
        echo "Error: Snapshot name cannot be '.' or '..'" >&2
        return 1
    fi

    return 0
}

cmd_create() {
    local name="${1:-}"
    local description="${2:-Snapshot created via CLI}"
    local subvolumes_arg="${3:-/}"

    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli create <name> [description] [subvolumes]" >&2
        exit 1
    fi

    # Validate snapshot name
    if ! validate_snapshot_name "$name"; then
        echo "Usage: waypoint-cli create <name> [description] [subvolumes]" >&2
        exit 1
    fi

    echo "Creating snapshot: $name"
    echo "Description: $description"

    # Parse subvolumes (comma-separated or single value)
    IFS=',' read -ra subvolumes_array <<< "$subvolumes_arg"
    local subvolume_count=${#subvolumes_array[@]}

    echo "Subvolumes: ${subvolumes_array[*]}"

    # Convert subvolumes to array format for D-Bus
    # The D-Bus method signature is CreateSnapshot(sas) - string, string, array of strings
    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        CreateSnapshot \
        'ssas' \
        "$name" \
        "$description" \
        "$subvolume_count" \
        "${subvolumes_array[@]}" 2>&1)

    # Parse result (format: "bs" true "message")
    if echo "$result" | grep -q "true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

format_timestamp() {
    local timestamp="$1"
    if command -v date >/dev/null 2>&1; then
        # Convert ISO 8601 to human readable with relative time
        local epoch
        epoch=$(date -d "$timestamp" +%s 2>/dev/null || echo "")
        if [[ -n "$epoch" ]]; then
            local now
            now=$(date +%s)
            local diff=$((now - epoch))
            local age=""

            if ((diff < 3600)); then
                age="$((diff / 60))m ago"
            elif ((diff < 86400)); then
                age="$((diff / 3600))h ago"
            elif ((diff < 604800)); then
                age="$((diff / 86400))d ago"
            else
                age=$(date -d "$timestamp" "+%Y-%m-%d")
            fi
            echo "$age"
        else
            echo "$timestamp"
        fi
    else
        echo "$timestamp"
    fi
}

parse_size() {
    # Convert human-readable size (e.g., 50G, 1T) to bytes
    local size="$1"
    local number
    local unit

    # Extract number and unit
    if [[ "$size" =~ ^([0-9]+)([KMGT])?$ ]]; then
        number="${BASH_REMATCH[1]}"
        unit="${BASH_REMATCH[2]}"
    else
        echo "Error: Invalid size format '$size'. Use format like: 50G, 1T, 500M" >&2
        return 1
    fi

    # Convert to bytes based on unit
    local bytes=$number
    case "$unit" in
        K) bytes=$((number * 1024)) ;;
        M) bytes=$((number * 1024 * 1024)) ;;
        G) bytes=$((number * 1024 * 1024 * 1024)) ;;
        T) bytes=$((number * 1024 * 1024 * 1024 * 1024)) ;;
        "") bytes=$number ;;
    esac

    echo "$bytes"
}

format_size() {
    # Convert bytes to human-readable format
    local bytes="$1"

    if [[ -z "$bytes" || "$bytes" == "null" ]]; then
        echo "0 B"
        return
    fi

    local units=("B" "KiB" "MiB" "GiB" "TiB")
    local unit_index=0
    local size=$bytes

    # Use bc if available, otherwise fall back to integer division
    if command -v bc >/dev/null 2>&1; then
        while (( $(echo "$size >= 1024" | bc 2>/dev/null || echo 0) == 1 && unit_index < 4 )); do
            size=$(echo "scale=2; $size / 1024" | bc)
            ((unit_index++))
        done
        printf "%.2f %s" "$size" "${units[$unit_index]}"
    else
        # Fallback to integer division for systems without bc
        while (( size >= 1024 && unit_index < 4 )); do
            size=$((size / 1024))
            ((unit_index++))
        done
        printf "%d %s" "$size" "${units[$unit_index]}"
    fi
}

format_json() {
    # Pretty print JSON if --json not specified, otherwise pass through
    local json="$1"
    local use_json="${2:-false}"

    if [[ "$use_json" == "true" ]]; then
        echo "$json"
    else
        if command -v jq >/dev/null 2>&1; then
            echo "$json" | jq '.'
        else
            echo "$json"
        fi
    fi
}

check_jq() {
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for this command" >&2
        echo "Install with: sudo xbps-install -S jq" >&2
        exit 1
    fi
}

cmd_list() {
    local verbose=false
    if [[ "${1:-}" == "--verbose" ]]; then
        verbose=true
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        ListSnapshots 2>&1)

    # Parse JSON result (format: s "json_data")
    # The result has format: s "[{...}]" - we need to extract just the JSON part
    local json
    json=$(echo "$result" | sed 's/^s "//' | sed 's/"$//' | sed 's/\\"/"/g')

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for listing snapshots" >&2
        echo "Install with: sudo xbps-install -S jq" >&2
        exit 1
    fi

    local count
    count=$(echo "$json" | jq '. | length')
    echo "Found $count snapshot(s):"
    echo

    if [[ "$verbose" == true ]]; then
        # Verbose output with details
        echo "$json" | jq -r '.[] |
            "Name:        \(.name)\n" +
            "Date:        \(.timestamp)\n" +
            "Description: \(.description // "None")\n" +
            "Packages:    \(.package_count // 0)\n" +
            "Subvolumes:  \(.subvolumes | join(", "))\n"'
    else
        # Compact table output
        printf "%-30s %-20s %s\n" "NAME" "AGE" "DESCRIPTION"
        printf "%-30s %-20s %s\n" "----" "---" "-----------"

        echo "$json" | jq -r '.[] | "\(.name)|\(.timestamp)|\(.description // "No description")"' | \
        while IFS='|' read -r name timestamp description; do
            local age
            age=$(format_timestamp "$timestamp")
            printf "%-30s %-20s %s\n" "$name" "$age" "$description"
        done
    fi
}

cmd_show() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli show <name>" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$name"; then
        echo "Error: Invalid snapshot name" >&2
        exit 1
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        ListSnapshots 2>&1)

    local json
    json=$(echo "$result" | sed 's/^s "//' | sed 's/"$//' | sed 's/\\"/"/g')

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required" >&2
        exit 1
    fi

    # Find the snapshot by name
    local snapshot
    snapshot=$(echo "$json" | jq -r --arg name "$name" '.[] | select(.name == $name)')

    if [[ -z "$snapshot" ]]; then
        echo "Error: Snapshot '$name' not found" >&2
        exit 1
    fi

    # Display detailed information
    echo "Snapshot Details"
    echo "================"
    echo
    echo "Name:        $(echo "$snapshot" | jq -r '.name')"
    echo "Created:     $(echo "$snapshot" | jq -r '.timestamp')"
    echo "Description: $(echo "$snapshot" | jq -r '.description // "None"')"
    echo "Packages:    $(echo "$snapshot" | jq -r '.package_count // 0')"

    local subvolumes
    subvolumes=$(echo "$snapshot" | jq -r '.subvolumes | join(", ")')
    echo "Subvolumes:  ${subvolumes:-/}"
    echo

    # Show top 10 packages if available
    local pkg_count
    pkg_count=$(echo "$snapshot" | jq -r '.packages | length')
    if [[ "$pkg_count" -gt 0 ]]; then
        echo "Sample Packages (first 10):"
        echo "$snapshot" | jq -r '.packages[0:10][] | "  • \(.name) (\(.version))"'
        if [[ "$pkg_count" -gt 10 ]]; then
            echo "  ... and $((pkg_count - 10)) more packages"
        fi
    fi
}

cmd_diff() {
    local snap1="${1:-}"
    local snap2="${2:-}"

    if [[ -z "$snap1" || -z "$snap2" ]]; then
        echo "Error: Two snapshot names are required" >&2
        echo "Usage: waypoint-cli diff <snapshot1> <snapshot2>" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$snap1" || ! validate_snapshot_name "$snap2"; then
        echo "Error: Invalid snapshot name" >&2
        exit 1
    fi

    echo "Comparing snapshots..."
    echo "  Base:    $snap1"
    echo "  Compare: $snap2"
    echo

    # First, compare packages (from snapshot metadata)
    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        ListSnapshots 2>&1)

    local json
    json=$(echo "$result" | sed 's/^s "//' | sed 's/"$//' | sed 's/\\"/"/g')

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required" >&2
        exit 1
    fi

    # Get packages for both snapshots
    local snap1_packages
    snap1_packages=$(echo "$json" | jq -r --arg name "$snap1" '.[] | select(.name == $name) | .packages')
    local snap2_packages
    snap2_packages=$(echo "$json" | jq -r --arg name "$snap2" '.[] | select(.name == $name) | .packages')

    if [[ -z "$snap1_packages" || "$snap1_packages" == "null" ]]; then
        echo "Error: Snapshot '$snap1' not found or has no package data" >&2
        exit 1
    fi

    if [[ -z "$snap2_packages" || "$snap2_packages" == "null" ]]; then
        echo "Error: Snapshot '$snap2' not found or has no package data" >&2
        exit 1
    fi

    # Compare packages using jq
    echo "Package Changes:"
    echo "================"
    echo

    # Find added packages
    local added
    added=$(jq -n --argjson old "$snap1_packages" --argjson new "$snap2_packages" \
        '$new | map(select(.name as $n | $old | map(.name) | contains([$n]) | not))')
    local added_count
    added_count=$(echo "$added" | jq '. | length')

    # Find removed packages
    local removed
    removed=$(jq -n --argjson old "$snap1_packages" --argjson new "$snap2_packages" \
        '$old | map(select(.name as $n | $new | map(.name) | contains([$n]) | not))')
    local removed_count
    removed_count=$(echo "$removed" | jq '. | length')

    # Find updated packages
    local updated
    updated=$(jq -n --argjson old "$snap1_packages" --argjson new "$snap2_packages" '
        [$old[] as $op | $new[] as $np |
         select($op.name == $np.name and $op.version != $np.version) |
         {name: $op.name, old_version: $op.version, new_version: $np.version}] | unique')
    local updated_count
    updated_count=$(echo "$updated" | jq '. | length')

    echo "Summary:"
    echo "  $added_count packages added"
    echo "  $removed_count packages removed"
    echo "  $updated_count packages updated"
    echo

    if [[ "$added_count" -gt 0 ]]; then
        echo "Added Packages:"
        echo "$added" | jq -r '.[] | "  + \(.name) (\(.version))"'
        echo
    fi

    if [[ "$removed_count" -gt 0 ]]; then
        echo "Removed Packages:"
        echo "$removed" | jq -r '.[] | "  - \(.name) (\(.version))"'
        echo
    fi

    if [[ "$updated_count" -gt 0 ]]; then
        echo "Updated Packages:"
        echo "$updated" | jq -r '.[] | "  ~ \(.name) (\(.old_version) → \(.new_version))"'
        echo
    fi

    if [[ "$added_count" -eq 0 && "$removed_count" -eq 0 && "$updated_count" -eq 0 ]]; then
        echo "No package changes detected."
        echo
    fi

    # Optionally show file changes
    echo "File Changes:"
    echo "============="
    echo "Analyzing file differences (this may take a moment)..."
    echo

    local file_result
    file_result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        CompareSnapshots \
        'ss' \
        "$snap1" \
        "$snap2" 2>&1)

    if echo "$file_result" | grep -q "bs true"; then
        local file_json
        file_json=$(echo "$file_result" | sed 's/^bs true s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        local file_changes
        file_changes=$(echo "$file_json" | jq -r '.')
        local total_files
        total_files=$(echo "$file_changes" | jq '. | length')

        if [[ "$total_files" -gt 0 ]]; then
            local added_files
            added_files=$(echo "$file_changes" | jq -r '[.[] | select(.change_type == "Added")] | length')
            local modified_files
            modified_files=$(echo "$file_changes" | jq -r '[.[] | select(.change_type == "Modified")] | length')
            local deleted_files
            deleted_files=$(echo "$file_changes" | jq -r '[.[] | select(.change_type == "Deleted")] | length')

            echo "  $added_files files added"
            echo "  $modified_files files modified"
            echo "  $deleted_files files deleted"
            echo
            echo "Run with --verbose to see file list (not yet implemented)"
        else
            echo "  No file changes detected"
        fi
    else
        echo "  Warning: File comparison failed or timed out"
        echo "  (This is normal for very large snapshots)"
    fi
}

cmd_delete() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli delete <name>" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$name"; then
        echo "Error: Invalid snapshot name" >&2
        exit 1
    fi

    echo "Deleting snapshot: $name"
    read -p "Are you sure? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        DeleteSnapshot \
        's' \
        "$name" 2>&1)

    if echo "$result" | grep -q "true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_restore() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli restore <name>" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$name"; then
        echo "Error: Invalid snapshot name" >&2
        exit 1
    fi

    echo "WARNING: This will restore your system to snapshot: $name"
    echo "You MUST reboot after this operation for changes to take effect."
    echo
    read -p "Are you absolutely sure? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    echo "Restoring snapshot: $name"
    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        RestoreSnapshot \
        's' \
        "$name" 2>&1)

    if echo "$result" | grep -q "true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
        echo
        echo "IMPORTANT: You MUST reboot now for changes to take effect!"
        echo "Run: sudo reboot"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_cleanup() {
    local schedule_based=true
    local dry_run=false

    # Parse all arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --schedule-based)
                schedule_based=true
                shift
                ;;
            --legacy)
                schedule_based=false
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                echo "Error: Unknown cleanup option '$1'. Use --schedule-based (default), --legacy, or --dry-run." >&2
                exit 1
                ;;
        esac
    done

    if [[ "$dry_run" == true ]]; then
        echo "Running snapshot cleanup in dry-run mode (preview only)..."
    else
        echo "Running snapshot cleanup..."
    fi

    if [[ "$schedule_based" == true ]]; then
        echo "Using per-schedule retention policies from schedules.toml"
    else
        echo "Using legacy global retention policy"
    fi
    echo

    # For dry-run, we need to call a different method or use a flag
    # Since the D-Bus API doesn't explicitly support dry-run, we'll simulate it
    # by fetching snapshots and showing which would be deleted
    if [[ "$dry_run" == true ]]; then
        check_jq
        local result
        result=$(busctl call --system \
            "$DBUS_SERVICE" \
            "$DBUS_PATH" \
            "$DBUS_INTERFACE" \
            ListSnapshots 2>&1)

        local json
        json=$(echo "$result" | sed 's/^s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        echo "Dry-run mode: The following snapshots would be evaluated for cleanup:"
        echo "$json" | jq -r '.[] | "  • \(.name) - \(.timestamp)"'
        echo
        echo "Note: Actual deletion depends on retention policy. Run without --dry-run to apply."
    else
        local result
        result=$(busctl call --system \
            "$DBUS_SERVICE" \
            "$DBUS_PATH" \
            "$DBUS_INTERFACE" \
            CleanupSnapshots \
            'b' \
            "$schedule_based" 2>&1)

        if echo "$result" | grep -q "true"; then
            echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
        else
            echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
            exit 1
        fi
    fi
}

# HIGH PRIORITY: Backup Operations

cmd_backup() {
    local snapshot="${1:-}"
    local destination="${2:-}"
    local parent="${3:-}"

    if [[ -z "$snapshot" || -z "$destination" ]]; then
        echo "Error: Snapshot name and destination are required" >&2
        echo "Usage: waypoint-cli backup <snapshot> <destination> [parent]" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$snapshot"; then
        exit 1
    fi

    local snapshot_path
    snapshot_path=$(snapshot_path_from_name "$snapshot")
    if [[ ! -e "$snapshot_path" ]]; then
        echo "Error: Snapshot '$snapshot' not found at $snapshot_path" >&2
        exit 1
    fi

    local parent_path=""
    if [[ -n "$parent" ]]; then
        if ! validate_snapshot_name "$parent"; then
            exit 1
        fi
        parent_path=$(snapshot_path_from_name "$parent")
        if [[ ! -e "$parent_path" ]]; then
            echo "Error: Parent snapshot '$parent' not found at $parent_path" >&2
            exit 1
        fi
    fi

    echo "Creating backup of snapshot: $snapshot ($snapshot_path)"
    echo "Destination: $destination"
    if [[ -n "$parent" ]]; then
        echo "Parent snapshot: $parent ($parent_path)"
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        BackupSnapshot \
        'sss' \
        "$snapshot_path" \
        "$destination" \
        "$parent_path" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_list_backups() {
    local destination="${1:-}"

    if [[ -z "$destination" ]]; then
        echo "Error: Destination is required" >&2
        echo "Usage: waypoint-cli list-backups <destination>" >&2
        exit 1
    fi

    echo "Listing backups on: $destination"
    echo

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        ListBackups \
        's' \
        "$destination" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        local json
        json=$(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        check_jq
        local count
        count=$(echo "$json" | jq '. | length')
        echo "Found $count backup(s):"
        echo
        if (( count == 0 )); then
            echo "  (none)"
        else
            echo "$json" | jq -r '.[] | "  • " + .'
        fi
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_verify_backup() {
    local snapshot="${1:-}"
    local destination="${2:-}"
    local snapshot_id="${3:-}"

    if [[ -z "$snapshot" || -z "$destination" || -z "$snapshot_id" ]]; then
        echo "Error: Snapshot path, destination, and snapshot ID are required" >&2
        echo "Usage: waypoint-cli verify-backup <snapshot> <destination> <id>" >&2
        exit 1
    fi

    local snapshot_path
    snapshot_path=$(snapshot_path_from_name "$snapshot")
    if [[ ! -e "$snapshot_path" ]]; then
        echo "Error: Snapshot '$snapshot' not found at $snapshot_path" >&2
        exit 1
    fi

    echo "Verifying backup integrity..."
    echo "Snapshot: $snapshot ($snapshot_path)"
    echo "Destination: $destination"
    echo "ID: $snapshot_id"
    echo

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        VerifyBackup \
        'sss' \
        "$snapshot_path" \
        "$destination" \
        "$snapshot_id" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_restore_backup() {
    local backup_path="${1:-}"
    local snapshots_dir="${2:-}"

    if [[ -z "$backup_path" || -z "$snapshots_dir" ]]; then
        echo "Error: Backup path and snapshots directory are required" >&2
        echo "Usage: waypoint-cli restore-backup <backup-path> <snapshots-dir>" >&2
        exit 1
    fi

    echo "WARNING: This will restore from external backup"
    echo "Backup path: $backup_path"
    echo "Target directory: $snapshots_dir"
    echo
    read -p "Are you sure? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        RestoreFromBackup \
        'ss' \
        "$backup_path" \
        "$snapshots_dir" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_scan_destinations() {
    local use_json=false
    if [[ "${1:-}" == "--json" ]]; then
        use_json=true
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        ScanBackupDestinations 2>&1)

    if echo "$result" | grep -q "bs true"; then
        local json
        json=$(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        if [[ "$use_json" == true ]]; then
            echo "$json"
        else
            check_jq
            local count
            count=$(echo "$json" | jq '. | length')
            echo "Found $count available backup destination(s):"
            echo
            echo "$json" | jq -r '.[] | "  • \(.mount_point) [label: \(.label // "n/a"), type: \(.drive_type), fs: \(.fstype), uuid: \(.uuid // "unknown")]"'
        fi
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_drive_stats() {
    local destination="${1:-}"

    if [[ -z "$destination" ]]; then
        echo "Error: Destination is required" >&2
        echo "Usage: waypoint-cli drive-stats <destination>" >&2
        exit 1
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        GetDriveStats \
        's' \
        "$destination" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        local json
        json=$(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        check_jq
        local total used available backups last oldest
        total=$(echo "$json" | jq -r '.total_bytes // 0')
        used=$(echo "$json" | jq -r '.used_bytes // 0')
        available=$(echo "$json" | jq -r '.available_bytes // 0')
        backups=$(echo "$json" | jq -r '.backup_count // 0')
        last=$(echo "$json" | jq -r '.last_backup_timestamp // "N/A"')
        oldest=$(echo "$json" | jq -r '.oldest_backup_timestamp // "N/A"')

        echo "Drive Statistics for: $destination"
        echo "=================================="
        echo
        printf "Total Space:     %s (%s bytes)\n" "$(format_size "$total")" "$total"
        printf "Used Space:      %s (%s bytes)\n" "$(format_size "$used")" "$used"
        printf "Available Space: %s (%s bytes)\n" "$(format_size "$available")" "$available"
        printf "Backups Stored:  %s\n" "$backups"
        printf "Newest Backup:   %s\n" "$last"
        printf "Oldest Backup:   %s\n" "$oldest"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

# HIGH PRIORITY: File Operations

cmd_restore_files() {
    local snapshot="${1:-}"
    shift

    if [[ -z "$snapshot" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli restore-files <snapshot> <file1> [file2...] [--target DIR] [--overwrite]" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$snapshot"; then
        exit 1
    fi

    local files=()
    local target_dir=""
    local overwrite=false

    # Parse remaining arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --target)
                target_dir="${2:-}"
                if [[ -z "$target_dir" ]]; then
                    echo "Error: --target requires a directory argument" >&2
                    exit 1
                fi
                shift 2
                ;;
            --overwrite)
                overwrite=true
                shift
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Error: At least one file path is required" >&2
        echo "Usage: waypoint-cli restore-files <snapshot> <file1> [file2...] [--target DIR] [--overwrite]" >&2
        exit 1
    fi

    # Use absolute directory for target (default to current working directory)
    if [[ -z "$target_dir" ]]; then
        target_dir="$(pwd -P)"
    else
        target_dir="$(cd "$target_dir" && pwd -P)"
    fi

    echo "Restoring files from snapshot: $snapshot"
    echo "Target directory: $target_dir"
    echo "Files to restore: ${files[*]}"
    if [[ "$overwrite" == true ]]; then
        echo "Overwrite: enabled"
    fi
    echo

    # Prepare array for D-Bus call
    local file_count=${#files[@]}

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        RestoreFiles \
        'sasb' \
        "$snapshot" \
        "$file_count" \
        "${files[@]}" \
        "$target_dir" \
        "$overwrite" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

# MEDIUM PRIORITY: Snapshot Information

cmd_verify() {
    local name="${1:-}"
    local use_json=false

    if [[ "${2:-}" == "--json" ]]; then
        use_json=true
    fi

    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli verify <name> [--json]" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$name"; then
        exit 1
    fi

    if [[ "$use_json" == false ]]; then
        echo "Verifying snapshot: $name"
        echo
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        VerifySnapshot \
        's' \
        "$name" 2>&1)

    # Result is just "s" with JSON data
    local json
    json=$(echo "$result" | sed 's/^s "//' | sed 's/"$//' | sed 's/\\"/"/g')

    if [[ "$use_json" == true ]]; then
        echo "$json"
    else
        check_jq
        echo "$json" | jq -r '
            if .valid then
                "✓ Snapshot is valid\n" +
                "Subvolumes verified: \(.subvolumes_verified)\n" +
                "Issues found: \(.issues // 0)"
            else
                "✗ Snapshot verification failed\n" +
                "Error: \(.error // "Unknown error")"
            end
        '
    fi
}

cmd_preview_restore() {
    local name="${1:-}"
    local use_json=false

    if [[ "${2:-}" == "--json" ]]; then
        use_json=true
    fi

    if [[ -z "$name" ]]; then
        echo "Error: Snapshot name is required" >&2
        echo "Usage: waypoint-cli preview-restore <name> [--json]" >&2
        exit 1
    fi

    if ! validate_snapshot_name "$name"; then
        exit 1
    fi

    if [[ "$use_json" == false ]]; then
        echo "Previewing restore for snapshot: $name"
        echo
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        PreviewRestore \
        's' \
        "$name" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        local json
        json=$(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        if [[ "$use_json" == true ]]; then
            echo "$json"
        else
            check_jq
            echo "$json" | jq -r '
                "Restore Preview\n" +
                "===============\n\n" +
                "Files that will be restored: \(.files_to_restore)\n" +
                "Files that will be removed: \(.files_to_remove)\n" +
                "Disk space required: \(.space_required)\n\n" +
                if (.warnings | length) > 0 then
                    "Warnings:\n" +
                    (.warnings | map("  ⚠ " + .) | join("\n"))
                else
                    "No warnings"
                end
            '
        fi
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

# MEDIUM PRIORITY: Quota Commands

cmd_quota() {
    local subcmd="${1:-}"
    shift

    case "$subcmd" in
        enable)
            cmd_quota_enable "$@"
            ;;
        disable)
            cmd_quota_disable "$@"
            ;;
        status)
            cmd_quota_status "$@"
            ;;
        set-limit)
            cmd_quota_set_limit "$@"
            ;;
        *)
            echo "Error: Unknown quota command: $subcmd" >&2
            echo "Usage: waypoint-cli quota {enable|disable|status|set-limit}" >&2
            exit 1
            ;;
    esac
}

cmd_quota_enable() {
    local use_simple=false

    if [[ "${1:-}" == "--simple" ]]; then
        use_simple=true
    fi

    echo "Enabling quotas..."
    if [[ "$use_simple" == true ]]; then
        echo "Using simple quota mode"
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        EnableQuotas \
        'b' \
        "$use_simple" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_quota_disable() {
    echo "Disabling quotas..."

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        DisableQuotas 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_quota_status() {
    local use_json=false

    if [[ "${1:-}" == "--json" ]]; then
        use_json=true
    fi

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        GetQuotaUsage 2>&1)

    if echo "$result" | grep -q "bs true"; then
        local json
        json=$(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//' | sed 's/\\"/"/g')

        if [[ "$use_json" == true ]]; then
            echo "$json"
        else
            check_jq
            echo "Quota Status"
            echo "============"
            echo
            echo "$json" | jq -r '
                "Enabled:     \(.enabled)\n" +
                "Usage:       \(.current_usage)\n" +
                "Limit:       \(.limit)\n" +
                "Percentage:  \(.percentage)%"
            '
        fi
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

cmd_quota_set_limit() {
    local size="${1:-}"

    if [[ -z "$size" ]]; then
        echo "Error: Size is required" >&2
        echo "Usage: waypoint-cli quota set-limit <size>" >&2
        echo "Example: waypoint-cli quota set-limit 100G" >&2
        exit 1
    fi

    # Parse size to bytes
    local bytes
    bytes=$(parse_size "$size")
    if [[ $? -ne 0 ]]; then
        exit 1
    fi

    echo "Setting quota limit to: $size ($bytes bytes)"

    local result
    result=$(busctl call --system \
        "$DBUS_SERVICE" \
        "$DBUS_PATH" \
        "$DBUS_INTERFACE" \
        SetQuotaLimit \
        't' \
        "$bytes" 2>&1)

    if echo "$result" | grep -q "bs true"; then
        echo "✓ Success: $(echo "$result" | sed 's/^bs true s "//' | sed 's/"$//')"
    else
        echo "✗ Failed: $(echo "$result" | sed 's/^bs false s "//' | sed 's/"$//')" >&2
        exit 1
    fi
}

# Main
if [[ $# -eq 0 ]]; then
    usage
fi

COMMAND="$1"
shift

case "$COMMAND" in
    # Snapshot Operations
    create)
        check_dbus_service
        cmd_create "$@"
        ;;
    list|ls)
        check_dbus_service
        cmd_list "$@"
        ;;
    show|info)
        check_dbus_service
        cmd_show "$@"
        ;;
    diff|compare)
        check_dbus_service
        cmd_diff "$@"
        ;;
    delete|del|rm)
        check_dbus_service
        cmd_delete "$@"
        ;;
    restore|rollback)
        check_dbus_service
        cmd_restore "$@"
        ;;
    cleanup)
        check_dbus_service
        cmd_cleanup "$@"
        ;;
    verify)
        check_dbus_service
        cmd_verify "$@"
        ;;
    preview-restore)
        check_dbus_service
        cmd_preview_restore "$@"
        ;;
    # Backup Operations
    backup)
        check_dbus_service
        cmd_backup "$@"
        ;;
    list-backups)
        check_dbus_service
        cmd_list_backups "$@"
        ;;
    verify-backup)
        check_dbus_service
        cmd_verify_backup "$@"
        ;;
    restore-backup)
        check_dbus_service
        cmd_restore_backup "$@"
        ;;
    scan-destinations)
        check_dbus_service
        cmd_scan_destinations "$@"
        ;;
    drive-stats)
        check_dbus_service
        cmd_drive_stats "$@"
        ;;
    # File Operations
    restore-files)
        check_dbus_service
        cmd_restore_files "$@"
        ;;
    # Quota Management
    quota)
        check_dbus_service
        cmd_quota "$@"
        ;;
    # Help
    help|--help|-h)
        usage
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        echo "Run 'waypoint-cli help' for usage information." >&2
        exit 1
        ;;
esac
